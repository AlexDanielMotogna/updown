# Engineering Standards

Non-negotiable rules for all contributors to the Parimutuel Pools project.

---

## Core Principles

### 1. No "Vibe Coding"

Every line of code must be intentional. Before writing code, understand:
- What problem you're solving
- Why this approach is correct
- What edge cases exist

If you can't explain your code, don't commit it.

### 2. No AI Branding

- No "Generated by Claude/ChatGPT" comments
- No "AI-assisted" signatures
- Code should be indistinguishable from human-written code

### 3. Layer Separation

```
┌─────────────────────────────────────────┐
│            UI Components                │  ← Only rendering & user events
├─────────────────────────────────────────┤
│              Hooks                      │  ← State management, data fetching
├─────────────────────────────────────────┤
│             Services                    │  ← API calls, blockchain interactions
├─────────────────────────────────────────┤
│              Domain                     │  ← Business logic, types, validation
└─────────────────────────────────────────┘
```

**Violations:**
- ❌ `fetch()` inside a React component
- ❌ Business logic in UI components
- ❌ Direct Solana calls from components

**Correct:**
- ✅ Component calls hook → hook calls service → service calls API

---

## Code Style

### TypeScript

```typescript
// ✅ Good: Explicit types, clear intent
interface Pool {
  id: string;
  asset: string;
  status: PoolStatus;
  totalUp: bigint;
  totalDown: bigint;
}

// ❌ Bad: Any types, unclear structure
const pool: any = { ...data };
```

### Naming Conventions

| Type | Convention | Example |
|------|------------|---------|
| Files (components) | PascalCase | `PoolCard.tsx` |
| Files (utilities) | camelCase | `formatPrice.ts` |
| Files (constants) | SCREAMING_SNAKE | `constants.ts` → `export const MAX_POOLS = 100` |
| Interfaces | PascalCase with I prefix (optional) | `Pool` or `IPool` |
| Enums | PascalCase | `PoolStatus.Active` |
| Functions | camelCase, verb prefix | `fetchPools`, `calculatePayout` |
| Boolean vars | is/has/can prefix | `isLoading`, `hasError`, `canClaim` |

### Folder Structure Rules

```
src/
├── components/          # React components only
│   └── ComponentName/
│       ├── index.tsx    # Main component
│       ├── ComponentName.styles.ts  # Styled components or sx props
│       └── ComponentName.test.tsx   # Tests
├── hooks/               # Custom React hooks
├── services/            # API & external service calls
├── stores/              # State management (Zustand)
├── types/               # TypeScript interfaces/types
├── utils/               # Pure utility functions
└── constants/           # App-wide constants
```

---

## Component Guidelines

### Do's

```typescript
// ✅ Hooks for data fetching
function PoolList() {
  const { pools, isLoading, error } = usePools();

  if (isLoading) return <Skeleton />;
  if (error) return <ErrorDisplay error={error} />;

  return <PoolGrid pools={pools} />;
}

// ✅ Small, focused components
function PoolCard({ pool }: { pool: Pool }) {
  return (
    <Card>
      <PoolHeader asset={pool.asset} />
      <PoolStats totalUp={pool.totalUp} totalDown={pool.totalDown} />
      <PoolActions poolId={pool.id} />
    </Card>
  );
}
```

### Don'ts

```typescript
// ❌ Fetching inside component
function BadPoolList() {
  const [pools, setPools] = useState([]);

  useEffect(() => {
    fetch('/api/pools').then(r => r.json()).then(setPools);
  }, []);

  // ...
}

// ❌ Giant monolithic component
function BadPoolPage() {
  // 500 lines of mixed concerns
}
```

---

## API Guidelines

### Request/Response Format

```typescript
// Standard API response wrapper
interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: {
    code: string;
    message: string;
  };
  meta?: {
    page?: number;
    total?: number;
  };
}
```

### Error Handling

```typescript
// ✅ Structured error responses
{
  "success": false,
  "error": {
    "code": "POOL_NOT_FOUND",
    "message": "Pool with ID xyz does not exist"
  }
}

// ❌ Unstructured errors
{
  "error": "Something went wrong"
}
```

### Validation

Use Zod for all input validation:

```typescript
import { z } from 'zod';

const depositSchema = z.object({
  poolId: z.string().uuid(),
  side: z.enum(['UP', 'DOWN']),
  amount: z.number().positive(),
});

// In controller
const result = depositSchema.safeParse(req.body);
if (!result.success) {
  return res.status(400).json({
    success: false,
    error: { code: 'VALIDATION_ERROR', message: result.error.message }
  });
}
```

---

## Database Guidelines

### Migrations

- Every schema change requires a migration
- Migrations must be reversible (up + down)
- Never modify existing migrations after they're deployed
- Test migrations against production-like data

### Audit Trail

Critical operations must be logged to `event_log`:

```typescript
await db.eventLog.create({
  eventType: 'POOL_RESOLVED',
  entityType: 'pool',
  entityId: pool.id,
  payload: {
    strikePrice,
    finalPrice,
    winnerSide,
    resolvedBy: 'scheduler',
  },
});
```

**Events to log:**
- Pool creation
- Pool status changes
- Deposits (with tx hash)
- Resolution (with prices)
- Claims (with payout amount)

---

## Solana Program Guidelines

### Account Validation

Always validate all accounts:

```rust
#[derive(Accounts)]
pub struct Deposit<'info> {
    #[account(mut)]
    pub pool: Account<'info, Pool>,

    #[account(
        init_if_needed,
        payer = user,
        space = 8 + UserBet::INIT_SPACE,
        seeds = [b"bet", pool.key().as_ref(), user.key().as_ref()],
        bump
    )]
    pub user_bet: Account<'info, UserBet>,

    // ... other accounts with proper constraints
}
```

### Error Messages

Provide clear, actionable error messages:

```rust
// ✅ Good
#[msg("Cannot deposit: join deadline has passed (deadline: {0}, current: {1})")]
JoinDeadlinePassed(i64, i64),

// ❌ Bad
#[msg("Error")]
GenericError,
```

---

## Git Workflow

### Branch Naming

```
feature/ticket-id-short-description
bugfix/ticket-id-short-description
hotfix/ticket-id-short-description

Examples:
feature/B2-deposit-instruction
bugfix/D4-countdown-timer
```

### Commit Messages

```
type(scope): short description

- Detailed bullet point 1
- Detailed bullet point 2

Refs: #ticket-id
```

Types: `feat`, `fix`, `refactor`, `test`, `docs`, `chore`

### PR Checklist

Before requesting review:

- [ ] Code compiles without warnings
- [ ] All tests pass
- [ ] New code has tests
- [ ] No console.log / debug statements
- [ ] Types are explicit (no `any`)
- [ ] Component follows layer separation
- [ ] Error states are handled
- [ ] Loading states are implemented
- [ ] Sensitive data is not exposed
- [ ] Migrations are tested

---

## Security Checklist

### Frontend

- [ ] No sensitive data in localStorage
- [ ] Wallet signatures only for intended actions
- [ ] Transaction previews before signing
- [ ] Input sanitization

### Backend

- [ ] Rate limiting on all endpoints
- [ ] Input validation (Zod)
- [ ] SQL injection prevention (parameterized queries)
- [ ] No secrets in logs
- [ ] CORS properly configured

### Solana Program

- [ ] All accounts validated
- [ ] Signer checks for privileged operations
- [ ] No arithmetic overflow (checked_add, etc.)
- [ ] PDAs properly derived
- [ ] Rent-exempt accounts

---

## Testing Requirements

### Unit Tests

- All utility functions
- All validation schemas
- Business logic in services
- Solana program instructions

### Integration Tests

- API endpoints
- Database operations
- Solana program flows (deposit → resolve → claim)

### Coverage Targets

| Layer | Minimum Coverage |
|-------|------------------|
| Solana Program | 90% |
| Backend Services | 80% |
| Frontend Hooks | 70% |
| UI Components | 50% |

---

## Performance Guidelines

### Frontend

- Lazy load routes
- Memoize expensive computations
- Virtualize long lists
- Optimize images (WebP, lazy loading)
- Target: < 3s initial load

### Backend

- Database indexes on frequently queried columns
- Connection pooling
- Cache static data (asset list, intervals)
- Target: < 200ms API response time

### Solana

- Minimize account reads
- Batch where possible
- Target: Single transaction for user actions
